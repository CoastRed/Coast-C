## 对象
## 类

Field：字段
Method：方法
Property：属性

三大特征：封装、多态、继承

```CSharp
[public] class 类名
{
    字段;
    属性;
    方法;
}
```

写好类之后需要创建对象，这个过程叫做类的实例化
自己写的类又叫自定义类，类不占内存，对象占内存

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _001
{
    class Person
    {
        //类的字段
        public string _name;
        public int _age;
        public char _gender;
        //类的方法
        public void CHLSS()
        {
            Console.WriteLine("我叫{0},我今年{1}岁了，我是{2}",_name,this._age,_gender);
        }
    }
}

```

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _001
{
    class Program
    {
        static void Main(string[] args)
        {
            //创建Person类的对象
            Person magic = new Person();
            magic._name = "角度思考";
            magic._age = 13;
            magic._gender = '男';
            //调用类的方法
            magic.CHLSS();
            Console.ReadKey();
        }
    }
}
```

属性：作用是保护字段，对字段的取值和赋值进行限定，理论上每一个字段都应该有属性保护
属性的本质：就是两个方法，一个叫get{}，一个叫set{}

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _001
{
    class Person
    {
        private string _name;
        private int _age;
        private char _gender;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        public int Age
        {
            get { return _age; }
            set {
                if(value < 0 || value > 100)
                {
                    value = 0;
                }
                _age = value;
                }
        }

        public char Gender
        {
            get {
                if (_gender != '男' && _gender != '女')
                {
                    return _gender = '男';
                }
                else
                {
                    return _gender;
                }
                }
            set { _gender = value; }
        }

        public void CHLSS()
        {
            Console.WriteLine("我叫{0},我今年{1}岁了，我是{2}",this.Name,this.Age,this.Gender);
        }
    }
}

```

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _001
{
    class Program
    {
        static void Main(string[] args)
        {
            //创建Person类的对象
            Person magic = new Person();
            magic.Name = "角度思考";
            magic.Age = 13;
            magic.Gender = '女';
            magic.CHLSS();
            Console.ReadKey();
        }
    }
}

```

## 静态和非静态区别

1. 在静态类中，既可以有实例(非静态)成员，也可以有静态成员
2. 在调用实例成员的时候，需要使用对象名.实例成员；
    在调用静态成员的时候，需要使用类名.静态成员名

总结：静态成员必须使用类名去调用，而实例成员必须使用对象名调用
          静态函数中只能访问静态成员，不允许访问实例成员
          实例函数中既可以使用静态成员，也可以使用实例成员
          静态类中只允许有静态成员，不允许出现实例成员

使用：
1. 如果想要你的类当作一个“工具类”去使用，这个时候可以考虑将类写成静态类
2. 静态类在整个项目中资源共享

## 构造函数
作用：帮助我们初始化对象（给对象的每个属性依次赋值）
构造是一个特殊的方法
1. 构造函数没有返回值，void也不能写
2. 构造函数的名称必须跟类名一致

创建对象的时候会调用构造函数
构造函数是可以有重载的
类中会有一个默认的无参数的构造函数，当你写一个新的构造函数之后，不管是有参的还是无参的，那个默许的无参数的构造函数都被干掉了

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _003_构造函数
{
    class Students
    {
        public Students(int a, string b)
        {
            this._a = a;
            this._b = b;
        }

        private int _a;
        public int A
        {
            set { _a = value; }
            get { return _a; }
        }

        private string _b;
        public string B
        {
            set { _b = value; }
            get { return _b; }
        }

    }
}

```

## new关键字

1. 在内存中开辟一块空间
2. 在开辟的空间中创建对象
3. 调用对象的构造函数进行初始化对象

## this关键字

1. 代表当前类的对象
2. 在类当中显示的调用本类的构造函数

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _003_构造函数
{
    class Students
    {
        public Students(int a, string b)
        {
            this._a = a;
            this._b = b;
        }
        public Students(int a):this(a,"")
        { 
        
        }

        private int _a;
        public int A
        {
            set { _a = value; }
            get { return _a; }
        }

        private string _b;
        public string B
        {
            set { _b = value; }
            get { return _b; }
        }

    }
}

```

## 析构函数

1. 当程序结束的时候析构函数才执行
2. 帮助我们释放资源

```CSharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _003_构造函数
{
    class Students
    {
        //当程序结束的时候析构函数才执行
        //帮助我们释放资源
        ~Students()
        {
            Console.WriteLine("我是析构函数");
        }

        public Students(int a, string b)
        {
            this._a = a;
            this._b = b;
        }
        public Students(int a):this(a,"")
        { 
        
        }

        private int _a;
        public int A
        {
            set { _a = value; }
            get { return _a; }
        }

        private string _b;
        public string B
        {
            set { _b = value; }
            get { return _b; }
        }

    }
}

```

## 命名空间

可以认为类是属于命名空间的
如果在当前项目中没有这个类的命名空间，需要我们手动导入这个类所在的命名空间

1. 用鼠标点
2. 快捷键：alt+shift+F10

在一个项目中引用另一个项目的类
1. 添加引用
2. 引用命名空间

## 值类型和引用类型

区别
1. 值类型和引用类型在内存上存储的地方不一样
2. 在传递值类型和传递引用类型的时候，传递的方式不一样
    值类型称为值传递，引用类型称为引用传递
    值类型：int、double、char、bool、decimal、struct、enum、
    引用类型：string、自定义类、数组
    值类型的值是存储在内存的栈当中
    引用类型的值是存储在内存的堆中

## 字符串

1. 字符串的不可变性
当给字符串赋值后，老值并没有被销毁，而是重新开辟了一块空间存储新值
当程序结束后，GC扫描整个内存，如果发现有的空间没有被指向，则立即把它销毁
2. 字符串可以看做是char类型的一个只读数组，可以使用**字符串[索引号]**访问字符串中的某个元素
    如果非要改变，需要把字符串转换为字符数组
    
```CSharp
string s = "abcd";
char[] chs = s.ToCharArray();
chs[0] = "r";
s = new string(chs)
```

